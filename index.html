<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFC Battle Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background: linear-gradient(to bottom, #581c87, #1e3a8a, #000000);
            min-height: 100vh;
        }
    </style>
</head>
<body>
    <div id="app" class="min-h-screen p-4">
        <div class="max-w-md mx-auto">
            <div class="bg-black/50 backdrop-blur-sm rounded-xl p-6 mb-4 border border-purple-500/30">
                <h1 class="text-3xl font-bold text-center mb-6 text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-blue-400">
                    NFC Battle
                </h1>
                
                <!-- HP Display -->
                <div class="mb-6">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-white font-semibold">Health Points</span>
                        <span id="hp-text" class="text-white font-bold">20/20</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-4 overflow-hidden">
                        <div id="hp-bar" class="h-full transition-all duration-300 bg-green-500" style="width: 100%"></div>
                    </div>
                </div>

                <!-- Status Indicators -->
                <div class="grid grid-cols-2 gap-2 mb-6">
                    <div id="shield-status" class="flex items-center gap-2 p-2 rounded bg-gray-700">
                        <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.618 5.984A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.031 9-11.622 0-1.042-.133-2.052-.382-3.016z"></path>
                        </svg>
                        <span class="text-white text-xs">VULNERABLE</span>
                    </div>
                    <div id="health-status" class="flex items-center gap-2 p-2 rounded bg-gray-700">
                        <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
                        </svg>
                        <span class="text-white text-xs">ALIVE</span>
                    </div>
                    <div id="critical-status" class="flex items-center gap-2 p-2 rounded bg-gray-700">
                        <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                        </svg>
                        <span class="text-white text-xs">NORMAL</span>
                    </div>
                    <div id="special-status" class="flex items-center gap-2 p-2 rounded bg-gray-700">
                        <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"></path>
                        </svg>
                        <span class="text-white text-xs">NONE</span>
                    </div>
                </div>

                <!-- NFC Status -->
                <div class="bg-gray-800 p-3 rounded-lg mb-4">
                    <div class="flex items-center gap-2">
                        <div id="nfc-indicator" class="w-3 h-3 rounded-full bg-red-500"></div>
                        <span id="nfc-status" class="text-white text-sm">Checking NFC...</span>
                    </div>
                </div>

                <!-- Start NFC Button (NEW) -->
                <button id="start-nfc-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white p-3 rounded-lg flex items-center justify-center gap-2 mb-4">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.111 16.404a5.5 5.5 0 017.778 0M12 20h.01m-7.08-7.071c3.904-3.905 10.236-3.905 14.141 0M1.394 9.393c5.857-5.857 15.355-5.857 21.213 0"></path>
                    </svg>
                    Enable NFC Scanning
                </button>

                <!-- Reset Button -->
                <button id="reset-btn" class="w-full bg-purple-600 hover:bg-purple-700 text-white p-3 rounded-lg flex items-center justify-center gap-2 mb-4">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    Reset Game
                </button>
            </div>

            <!-- Game Log -->
            <div class="bg-black/50 backdrop-blur-sm rounded-xl p-4 border border-purple-500/30">
                <h2 class="text-white font-semibold mb-3">Game Log</h2>
                <div id="game-log" class="bg-gray-900 rounded p-3 h-48 overflow-y-auto">
                    <p class="text-gray-400 text-sm">Click 'Enable NFC Scanning' to start...</p>
                </div>
            </div>

            <!-- Instructions -->
            <div class="mt-4 bg-black/30 rounded-lg p-4">
                <h3 class="text-white font-semibold mb-2">Flipper Zero NFC Commands:</h3>
                <ul class="text-gray-300 text-sm space-y-1">
                    <li>• <strong>"ATTACK1"</strong> - Deal 1 damage</li>
                    <li>• <strong>"ATTACK3"</strong> - Deal 3 damage</li>
                    <li>• <strong>"ATTACK5"</strong> - Deal 5 damage</li>
                    <li>• <strong>"HEAL1"</strong> - Restore 1 HP</li>
                    <li>• <strong>"HEAL2"</strong> - Restore 2 HP</li>
                    <li>• <strong>"HEAL3"</strong> - Restore 3 HP</li>
                    <li>• <strong>"BLOCK"</strong> or <strong>"SHIELD"</strong> - Block next attack</li>
                    <li>• <strong>"RESET"</strong> - Reset the game</li>
                    <li>• <strong>"STATUS"</strong> - Check current health</li>
                </ul>
                <div class="mt-3 p-2 bg-yellow-900/30 rounded border border-yellow-500/50">
                    <p class="text-yellow-300 text-xs">
                        <strong>💡 Tips:</strong> Create text records in NFC Maker with these exact words. 
                        Game works best on Android phones with Chrome browser and NFC enabled.
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        class NFCBattleGame {
            constructor() {
                this.hp = 20;
                this.maxHp = 20;
                this.isBlocked = false;
                this.gameLog = [];
                this.nfcSupported = false;
                this.isListening = false;
                this.nfcReader = null;
                
                // New spell effects
                this.criticalNext = false;
                this.boostNext = 0;
                this.weakenNext = false;
                this.reflectActive = false;
                this.counterActive = false;
                this.hasRevive = false;
                this.lifestealActive = false;
                
                this.initializeElements();
                this.setupEventListeners();
                this.checkNFCSupport();
            }

            initializeElements() {
                this.hpText = document.getElementById('hp-text');
                this.hpBar = document.getElementById('hp-bar');
                this.shieldStatus = document.getElementById('shield-status');
                this.healthStatus = document.getElementById('health-status');
                this.criticalStatus = document.getElementById('critical-status');
                this.specialStatus = document.getElementById('special-status');
                this.nfcIndicator = document.getElementById('nfc-indicator');
                this.nfcStatus = document.getElementById('nfc-status');
                this.gameLogEl = document.getElementById('game-log');
                this.resetBtn = document.getElementById('reset-btn');
                this.startNfcBtn = document.getElementById('start-nfc-btn');
            }

            setupEventListeners() {
                this.resetBtn.addEventListener('click', () => this.resetGame());
                this.startNfcBtn.addEventListener('click', () => this.requestNFCPermission());
            }

            async checkNFCSupport() {
                if ('NDEFReader' in window) {
                    this.nfcSupported = true;
                    this.updateNFCStatus('NFC supported! Click "Enable NFC Scanning" to start.');
                    this.addToLog('NFC hardware detected. Ready to start scanning.');
                } else {
                    this.nfcSupported = false;
                    this.updateNFCStatus('NFC not supported on this device/browser.');
                    this.addToLog('NFC not supported. Use Chrome on Android with NFC enabled.');
                    this.startNfcBtn.disabled = true;
                    this.startNfcBtn.textContent = 'NFC Not Supported';
                    this.startNfcBtn.className = 'w-full bg-gray-600 text-white p-3 rounded-lg flex items-center justify-center gap-2 mb-4 cursor-not-allowed';
                }
            }

            async requestNFCPermission() {
                if (!this.nfcSupported) {
                    this.addToLog('❌ NFC not supported on this device.');
                    return;
                }

                // Prevent multiple permission requests
                if (this.isListening) {
                    this.addToLog('⚠️ NFC is already active!');
                    return;
                }

                this.addToLog('🔄 Requesting NFC permissions...');
                this.updateNFCStatus('Requesting NFC permissions...', false);
                
                // Disable button during request
                this.startNfcBtn.disabled = true;
                this.startNfcBtn.textContent = 'Requesting Permission...';

                try {
                    // Clean up any existing reader
                    if (this.nfcReader) {
                        try {
                            await this.nfcReader.stop();
                        } catch (e) {
                            // Ignore errors when stopping
                        }
                    }

                    // Create a new NDEFReader instance
                    this.nfcReader = new NDEFReader();
                    
                    // Add event listeners with proper error handling
                    this.nfcReader.addEventListener("reading", (event) => {
                        try {
                            this.handleNFCReading(event);
                        } catch (readError) {
                            this.addToLog(`❌ Error processing NFC data: ${readError.message}`);
                        }
                    });

                    this.nfcReader.addEventListener("readingerror", (event) => {
                        this.addToLog(`❌ NFC reading error: ${event.message || 'Unknown NFC error'}`);
                        this.updateNFCStatus('❌ NFC reading error occurred', false);
                    });

                    // Add abort signal for timeout handling
                    const abortController = new AbortController();
                    const timeoutId = setTimeout(() => {
                        abortController.abort();
                        this.addToLog('❌ NFC permission request timed out');
                    }, 10000); // 10 second timeout

                    // Request permission and start scanning with timeout
                    await this.nfcReader.scan({ signal: abortController.signal });
                    
                    clearTimeout(timeoutId);
                    
                    // If we get here, permission was granted and scanning started
                    this.isListening = true;
                    this.updateNFCStatus('✅ NFC scanning active - tap your Flipper Zero!', true);
                    this.addToLog('✅ NFC scanning started successfully!');
                    this.addToLog('📱 Hold your Flipper Zero close to this device and emulate NFC tags');
                    
                    // Update button to show success
                    this.startNfcBtn.textContent = '✅ NFC Active';
                    this.startNfcBtn.className = 'w-full bg-green-600 text-white p-3 rounded-lg flex items-center justify-center gap-2 mb-4 cursor-not-allowed';

                } catch (error) {
                    // Re-enable button on error
                    this.startNfcBtn.disabled = false;
                    this.startNfcBtn.textContent = 'Enable NFC Scanning';
                    
                    this.addToLog(`❌ NFC Error: ${error.message || 'Unknown error'}`);
                    this.updateNFCStatus(`❌ NFC Error: ${error.message || 'Unknown error'}`, false);
                    this.isListening = false;
                    
                    // Provide comprehensive error guidance
                    if (error.name === 'NotAllowedError') {
                        this.addToLog('🔧 Permission denied. Solutions:');
                        this.addToLog('   1. Click the lock icon next to URL → Allow NFC');
                        this.addToLog('   2. Go to chrome://settings/content/nfc → Allow');
                        this.addToLog('   3. Refresh page and try again');
                    } else if (error.name === 'NotSupportedError') {
                        this.addToLog('🔧 NFC not supported. Try:');
                        this.addToLog('   1. Use Chrome browser on Android');
                        this.addToLog('   2. Make sure NFC is ON in phone settings');
                        this.addToLog('   3. Update Chrome to latest version');
                    } else if (error.name === 'AbortError') {
                        this.addToLog('🔧 Permission request timed out. Try again.');
                    } else if (error.name === 'InvalidStateError') {
                        this.addToLog('🔧 NFC scanner in invalid state. Refresh page.');
                    } else {
                        this.addToLog('🔧 Unknown error. Troubleshooting:');
                        this.addToLog('   1. Make sure NFC is enabled in device settings');
                        this.addToLog('   2. Close other apps that might use NFC');
                        this.addToLog('   3. Try restarting browser');
                    }
                }
            }

            handleNFCReading(event) {
                try {
                    const { message, serialNumber } = event;
                    
                    if (!message || !message.records) {
                        this.addToLog('❌ Invalid NFC message received');
                        return;
                    }

                    this.addToLog(`📡 NFC tag detected (Serial: ${serialNumber || 'Unknown'})`);
                    
                    let commandFound = false;
                    
                    for (const record of message.records) {
                        if (record.recordType === "text") {
                            try {
                                // Handle different text record formats
                                let command = '';
                                
                                if (record.encoding) {
                                    const textDecoder = new TextDecoder(record.encoding);
                                    command = textDecoder.decode(record.data);
                                } else {
                                    // Try UTF-8 first, then fallback to ASCII
                                    try {
                                        const utf8Decoder = new TextDecoder('utf-8', { fatal: true });
                                        command = utf8Decoder.decode(record.data);
                                    } catch (utf8Error) {
                                        const asciiDecoder = new TextDecoder('ascii');
                                        command = asciiDecoder.decode(record.data);
                                    }
                                }
                                
                                // Clean and validate command
                                command = command.toUpperCase().trim().replace(/\0/g, ''); // Remove null bytes
                                
                                if (command.length > 0) {
                                    this.handleNFCCommand(command);
                                    commandFound = true;
                                } else {
                                    this.addToLog('❌ Empty command received from NFC tag');
                                }
                                
                            } catch (decodeError) {
                                this.addToLog(`❌ Error decoding NFC text: ${decodeError.message}`);
                                // Try raw bytes as backup
                                try {
                                    const rawString = Array.from(new Uint8Array(record.data))
                                        .map(byte => String.fromCharCode(byte))
                                        .join('')
                                        .toUpperCase()
                                        .trim();
                                    if (rawString.length > 0) {
                                        this.addToLog(`🔧 Trying raw decode: "${rawString}"`);
                                        this.handleNFCCommand(rawString);
                                        commandFound = true;
                                    }
                                } catch (rawError) {
                                    this.addToLog(`❌ Raw decode also failed: ${rawError.message}`);
                                }
                            }
                        } else if (record.recordType === "url") {
                            this.addToLog(`ℹ️ URL record detected (not supported): ${record.data}`);
                        } else {
                            this.addToLog(`ℹ️ Unsupported record type: ${record.recordType}`);
                        }
                    }
                    
                    if (!commandFound) {
                        this.addToLog('❌ No valid text commands found in NFC tag');
                        this.addToLog('💡 Make sure your Flipper Zero is emulating a text record');
                    }
                    
                } catch (eventError) {
                    this.addToLog(`❌ Error processing NFC reading event: ${eventError.message}`);
                }
            }

            updateNFCStatus(message, isActive = false) {
                this.nfcStatus.textContent = message;
                this.nfcIndicator.className = `w-3 h-3 rounded-full ${isActive ? 'bg-green-500' : 'bg-red-500'}`;
            }

            handleNFCCommand(command) {
                // Validate command format
                if (!command || typeof command !== 'string') {
                    this.addToLog(`❌ Invalid command format received`);
                    return;
                }
                
                const cleanCommand = command.trim().toUpperCase();
                this.addToLog(`📡 Processing command: "${cleanCommand}"`);
                
                // Check if game is over
                if (this.hp === 0 && !cleanCommand.includes('RESET')) {
                    this.addToLog(`💀 Cannot execute commands when defeated! Use RESET or click Reset button.`);
                    return;
                }
                
                // Process attack commands
                if (cleanCommand.startsWith('ATTACK')) {
                    const damageStr = cleanCommand.replace('ATTACK', '');
                    const damage = parseInt(damageStr);
                    
                    if (isNaN(damage) || damage < 1 || damage > 10) {
                        this.addToLog(`❌ Invalid attack value: "${damageStr}". Use ATTACK1, ATTACK3, or ATTACK5`);
                        return;
                    }
                    
                    this.handleAttack(damage);
                    return;
                }
                
                // Process heal commands  
                if (cleanCommand.startsWith('HEAL')) {
                    const healStr = cleanCommand.replace('HEAL', '');
                    const healAmount = parseInt(healStr);
                    
                    if (isNaN(healAmount) || healAmount < 1 || healAmount > 5) {
                        this.addToLog(`❌ Invalid heal value: "${healStr}". Use HEAL1, HEAL2, or HEAL3`);
                        return;
                    }
                    
                    this.handleHeal(healAmount);
                    return;
                }
                
                // Process defense commands
                if (cleanCommand === 'BLOCK' || cleanCommand === 'SHIELD') {
                    this.handleBlock();
                    return;
                }
                
                // Process new spell commands
                if (cleanCommand === 'CRITICAL') {
                    this.handleCritical();
                    return;
                }
                
                if (cleanCommand === 'GAMBLE') {
                    this.handleGamble();
                    return;
                }
                
                if (cleanCommand === 'BOOST') {
                    this.handleBoost();
                    return;
                }
                
                if (cleanCommand === 'WEAKEN') {
                    this.handleWeaken();
                    return;
                }
                
                if (cleanCommand === 'COUNTER') {
                    this.handleCounter();
                    return;
                }
                
                if (cleanCommand === 'REFLECT') {
                    this.handleReflect();
                    return;
                }
                
                if (cleanCommand === 'SWAP') {
                    this.handleSwap();
                    return;
                }
                
                if (cleanCommand === 'REVIVE') {
                    this.handleRevive();
                    return;
                }
                
                if (cleanCommand === 'LIFESTEAL') {
                    this.handleLifesteal();
                    return;
                }
                
                // Process utility commands
                if (cleanCommand === 'RESET' || cleanCommand === 'RESTART') {
                    this.addToLog(`🔄 Reset command received via NFC`);
                    this.resetGame();
                    return;
                }
                
                if (cleanCommand === 'STATUS' || cleanCommand === 'INFO') {
                    this.addToLog(`📊 Current Status: HP ${this.hp}/${this.maxHp}, Shield: ${this.isBlocked ? 'ACTIVE' : 'OFF'}`);
                    return;
                }
                
                // Unknown command
                this.addToLog(`❓ Unknown command: "${cleanCommand}"`);
                this.addToLog(`💡 Basic: ATTACK1-5, HEAL1-3, BLOCK, SHIELD`);
                this.addToLog(`💡 Spells: CRITICAL, GAMBLE, BOOST, WEAKEN, COUNTER`);
                this.addToLog(`💡 Advanced: REFLECT, SWAP, REVIVE, LIFESTEAL`);
                this.addToLog(`💡 Utility: RESET, STATUS`);
            }

            handleAttack(damage) {
                if (this.hp === 0 && !this.hasRevive) {
                    this.addToLog("💀 Cannot take damage when already defeated!");
                    return;
                }
                
                // Apply critical hit
                if (this.criticalNext) {
                    damage *= 2;
                    this.addToLog(`⚡ CRITICAL HIT! Damage doubled to ${damage}!`);
                    this.criticalNext = false;
                    this.updateCriticalStatus();
                }
                
                // Apply boost
                if (this.boostNext > 0) {
                    damage += this.boostNext;
                    this.addToLog(`💪 BOOST applied! +${this.boostNext} damage (total: ${damage})`);
                    this.boostNext = 0;
                    this.updateSpecialStatus();
                }
                
                // Apply weaken (enemy attacks are weakened)
                if (this.weakenNext) {
                    damage = Math.max(1, damage - 1);
                    this.addToLog(`🛡️ WEAKEN effect! Damage reduced by 1 (total: ${damage})`);
                    this.weakenNext = false;
                    this.updateSpecialStatus();
                }
                
                // Check for reflect
                if (this.reflectActive) {
                    this.addToLog(`🪞 REFLECT activated! Taking ${damage} damage but reflecting it back!`);
                    // Self-reflect mechanism: you take damage but immediately heal for same amount
                    this.reflectActive = false;
                    this.updateSpecialStatus();
                    
                    const oldHp = this.hp;
                    this.hp = Math.max(0, this.hp - damage);
                    this.addToLog(`⚔️ Took ${damage} damage! HP: ${oldHp} → ${this.hp}/${this.maxHp}`);
                    
                    // Reflect healing
                    const reflectHeal = Math.min(this.maxHp - this.hp, damage);
                    if (reflectHeal > 0) {
                        this.hp += reflectHeal;
                        this.addToLog(`🪞 Reflected ${reflectHeal} damage back as healing!`);
                    }
                    
                    this.updateDisplay();
                    this.flashStatus('reflect');
                    return;
                }
                
                // Check for counter
                if (this.counterActive && this.hp > 0) {
                    this.addToLog(`⚔️ COUNTER activated! Taking damage but striking back!`);
                    this.counterActive = false;
                    this.updateSpecialStatus();
                    
                    // Take damage first
                    const oldHp = this.hp;
                    this.hp = Math.max(0, this.hp - damage);
                    this.addToLog(`⚔️ Took ${damage} damage! HP: ${oldHp} → ${this.hp}/${this.maxHp}`);
                    
                    // Counter attack
                    if (this.hp > 0) {
                        this.addToLog(`💥 Counter attack deals 2 damage back!`);
                        // In single player, this becomes self-healing
                        const counterHeal = Math.min(2, this.maxHp - this.hp);
                        if (counterHeal > 0) {
                            this.hp += counterHeal;
                            this.addToLog(`⚡ Counter energy heals you for ${counterHeal} HP!`);
                        }
                    }
                    
                    this.updateDisplay();
                    this.flashStatus('counter');
                    return;
                }
                
                // Regular attack processing
                if (this.isBlocked) {
                    this.addToLog(`🛡️ Attack blocked! ${damage} damage negated.`);
                    this.isBlocked = false;
                    this.updateShieldStatus();
                    this.flashStatus('block');
                } else {
                    const oldHp = this.hp;
                    let newHp = Math.max(0, this.hp - damage);
                    
                    // Check for lifesteal
                    if (this.lifestealActive && newHp > 0) {
                        const lifestealAmount = Math.min(1, this.maxHp - newHp);
                        if (lifestealAmount > 0) {
                            newHp += lifestealAmount;
                            this.addToLog(`🧛 LIFESTEAL: Gained ${lifestealAmount} HP from damage taken!`);
                        }
                    }
                    
                    this.hp = newHp;
                    this.addToLog(`⚔️ Took ${damage} damage! HP: ${oldHp} → ${newHp}/${this.maxHp}`);
                    this.updateDisplay();
                    this.flashStatus('damage');
                    
                    if (newHp === 0) {
                        if (this.hasRevive) {
                            this.addToLog("💀 Defeated! But REVIVE is ready...");
                            this.addToLog("🔄 Use REVIVE command to come back with 5 HP!");
                        } else {
                            this.addToLog("💀 Game Over! You have been defeated.");
                            this.addToLog("🔄 Use RESET command or click Reset button to play again.");
                            this.flashStatus('death');
                        }
                    } else if (newHp <= 5) {
                        this.addToLog("⚠️ Critical health! Consider healing.");
                    }
                }
            }

            handleHeal(healAmount) {
                if (this.hp === 0) {
                    this.addToLog("💀 Cannot heal when defeated! Use RESET first.");
                    return;
                }
                
                const oldHp = this.hp;
                const newHp = Math.min(this.maxHp, this.hp + healAmount);
                const actualHeal = newHp - this.hp;
                this.hp = newHp;
                
                if (actualHeal > 0) {
                    this.addToLog(`❤️ Healed ${actualHeal} HP! HP: ${oldHp} → ${newHp}/${this.maxHp}`);
                    this.flashStatus('heal');
                } else {
                    this.addToLog(`❤️ Already at full health! (${this.hp}/${this.maxHp})`);
                }
                this.updateDisplay();
            }

            handleBlock() {
                if (this.hp === 0) {
                    this.addToLog("💀 Cannot block when defeated!");
                    return;
                }
                
                if (this.isBlocked) {
                    this.addToLog("🛡️ Shield already active!");
                    return;
                }
                
                this.isBlocked = true;
                this.addToLog("🛡️ Shield activated! Next attack will be blocked.");
                this.updateShieldStatus();
                this.flashStatus('shield');
            }

            updateDisplay() {
                this.hpText.textContent = `${this.hp}/${this.maxHp}`;
                const percentage = this.hp / this.maxHp;
                this.hpBar.style.width = `${percentage * 100}%`;
                
                if (percentage > 0.6) {
                    this.hpBar.className = 'h-full transition-all duration-300 bg-green-500';
                } else if (percentage > 0.3) {
                    this.hpBar.className = 'h-full transition-all duration-300 bg-yellow-500';
                } else {
                    this.hpBar.className = 'h-full transition-all duration-300 bg-red-500';
                }

                const healthStatusSpan = this.healthStatus.querySelector('span');
                if (this.hp === 0) {
                    this.healthStatus.className = 'flex items-center gap-2 p-2 rounded bg-red-600';
                    healthStatusSpan.textContent = 'DEFEATED';
                } else {
                    this.healthStatus.className = 'flex items-center gap-2 p-2 rounded bg-gray-700';
                    healthStatusSpan.textContent = 'ALIVE';
                }
            }

            updateShieldStatus() {
                const shieldStatusSpan = this.shieldStatus.querySelector('span');
                if (this.isBlocked) {
                    this.shieldStatus.className = 'flex items-center gap-2 p-2 rounded bg-blue-600';
                    shieldStatusSpan.textContent = 'PROTECTED';
                } else {
                    this.shieldStatus.className = 'flex items-center gap-2 p-2 rounded bg-gray-700';
                    shieldStatusSpan.textContent = 'VULNERABLE';
                }
            }

            updateCriticalStatus() {
                const criticalStatusSpan = this.criticalStatus.querySelector('span');
                if (this.criticalNext) {
                    this.criticalStatus.className = 'flex items-center gap-2 p-2 rounded bg-red-600';
                    criticalStatusSpan.textContent = 'CRITICAL';
                } else {
                    this.criticalStatus.className = 'flex items-center gap-2 p-2 rounded bg-gray-700';
                    criticalStatusSpan.textContent = 'NORMAL';
                }
            }

            updateSpecialStatus() {
                const specialStatusSpan = this.specialStatus.querySelector('span');
                let statusText = 'NONE';
                let statusClass = 'flex items-center gap-2 p-2 rounded bg-gray-700';
                
                if (this.boostNext > 0) {
                    statusText = 'BOOST';
                    statusClass = 'flex items-center gap-2 p-2 rounded bg-orange-600';
                } else if (this.weakenNext) {
                    statusText = 'WEAKEN';
                    statusClass = 'flex items-center gap-2 p-2 rounded bg-purple-600';
                } else if (this.reflectActive) {
                    statusText = 'REFLECT';
                    statusClass = 'flex items-center gap-2 p-2 rounded bg-cyan-600';
                } else if (this.counterActive) {
                    statusText = 'COUNTER';
                    statusClass = 'flex items-center gap-2 p-2 rounded bg-red-600';
                } else if (this.hasRevive) {
                    statusText = 'REVIVE';
                    statusClass = 'flex items-center gap-2 p-2 rounded bg-green-600';
                } else if (this.lifestealActive) {
                    statusText = 'LIFESTEAL';
                    statusClass = 'flex items-center gap-2 p-2 rounded bg-pink-600';
                }
                
                this.specialStatus.className = statusClass;
                specialStatusSpan.textContent = statusText;
            }

            addToLog(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `${timestamp}: ${message}`;
                this.gameLog.push(logEntry);
                
                if (this.gameLog.length > 15) {
                    this.gameLog.shift();
                }
                
                this.updateGameLog();
            }

            updateGameLog() {
                if (this.gameLog.length === 0) {
                    this.gameLogEl.innerHTML = '<p class="text-gray-400 text-sm">Click "Enable NFC Scanning" to start...</p>';
                } else {
                    this.gameLogEl.innerHTML = this.gameLog
                        .map(entry => `<div class="text-green-300 text-sm mb-1 font-mono">${entry}</div>`)
                        .join('');
                }
                
                this.gameLogEl.scrollTop = this.gameLogEl.scrollHeight;
            }

            resetGame() {
                this.hp = 20;
                this.isBlocked = false;
                this.gameLog = [];
                this.updateDisplay();
                this.updateShieldStatus();
                this.updateGameLog();
                this.addToLog("🎮 Game reset! Ready for battle.");
                this.addToLog("📱 NFC scanning is still active - ready for commands!");
            }

            // New spell handlers
            handleCritical() {
                if (this.hp === 0) {
                    this.addToLog("💀 Cannot cast spells when defeated!");
                    return;
                }
                
                if (this.criticalNext) {
                    this.addToLog("⚡ Critical hit already prepared!");
                    return;
                }
                
                this.criticalNext = true;
                this.addToLog("⚡ CRITICAL prepared! Next attack will deal double damage!");
                this.updateCriticalStatus();
                this.flashStatus('critical');
            }
            
            handleGamble() {
                if (this.hp === 0) {
                    this.addToLog("💀 Cannot gamble when defeated!");
                    return;
                }
                
                const outcomes = [
                    { type: 'heal', value: 5, text: '🎰 JACKPOT! Healed 5 HP!' },
                    { type: 'damage', value: 3, text: '🎰 Bad luck! Took 3 damage!' },
                    { type: 'heal', value: 2, text: '🎰 Lucky! Healed 2 HP!' },
                    { type: 'damage', value: 1, text: '🎰 Unlucky! Took 1 damage!' },
                    { type: 'critical', value: 0, text: '🎰 Amazing! Next attack is critical!' },
                    { type: 'shield', value: 0, text: '🎰 Great! Shield activated!' }
                ];
                
                const result = outcomes[Math.floor(Math.random() * outcomes.length)];
                this.addToLog(result.text);
                
                if (result.type === 'heal') {
                    const oldHp = this.hp;
                    this.hp = Math.min(this.maxHp, this.hp + result.value);
                    this.addToLog(`❤️ HP: ${oldHp} → ${this.hp}/${this.maxHp}`);
                    this.updateDisplay();
                } else if (result.type === 'damage') {
                    const oldHp = this.hp;
                    this.hp = Math.max(0, this.hp - result.value);
                    this.addToLog(`💔 HP: ${oldHp} → ${this.hp}/${this.maxHp}`);
                    this.updateDisplay();
                } else if (result.type === 'critical') {
                    this.criticalNext = true;
                    this.updateCriticalStatus();
                } else if (result.type === 'shield') {
                    this.isBlocked = true;
                    this.updateShieldStatus();
                }
                
                this.flashStatus('gamble');
            }
            
            handleBoost() {
                if (this.hp === 0) {
                    this.addToLog("💀 Cannot cast spells when defeated!");
                    return;
                }
                
                if (this.boostNext > 0) {
                    this.addToLog("💪 Boost already active!");
                    return;
                }
                
                this.boostNext = 2;
                this.addToLog("💪 BOOST activated! Next attack deals +2 extra damage!");
                this.updateSpecialStatus();
                this.flashStatus('boost');
            }
            
            handleWeaken() {
                if (this.hp === 0) {
                    this.addToLog("💀 Cannot cast spells when defeated!");
                    return;
                }
                
                if (this.weakenNext) {
                    this.addToLog("🛡️ Weaken already active!");
                    return;
                }
                
                this.weakenNext = true;
                this.addToLog("🛡️ WEAKEN cast! Next incoming attack deals -1 damage!");
                this.updateSpecialStatus();
                this.flashStatus('weaken');
            }
            
            handleCounter() {
                if (this.hp === 0) {
                    this.addToLog("💀 Cannot cast spells when defeated!");
                    return;
                }
                
                if (this.counterActive) {
                    this.addToLog("⚔️ Counter stance already active!");
                    return;
                }
                
                this.counterActive = true;
                this.addToLog("⚔️ COUNTER stance activated! Next attack will be countered!");
                this.updateSpecialStatus();
                this.flashStatus('counter');
            }
            
            handleReflect() {
                if (this.hp === 0) {
                    this.addToLog("💀 Cannot cast spells when defeated!");
                    return;
                }
                
                if (this.reflectActive) {
                    this.addToLog("🪞 Reflect already active!");
                    return;
                }
                
                this.reflectActive = true;
                this.addToLog("🪞 REFLECT activated! Next attack will be reflected as healing!");
                this.updateSpecialStatus();
                this.flashStatus('reflect');
            }
            
            handleSwap() {
                if (this.hp === 0) {
                    this.addToLog("💀 Cannot swap when defeated!");
                    return;
                }
                
                // In single-player mode, swap with "ideal" HP (15)
                const targetHp = 15;
                const oldHp = this.hp;
                
                if (oldHp === targetHp) {
                    this.addToLog("🔄 SWAP: No change - already at balanced HP!");
                    return;
                }
                
                this.hp = targetHp;
                this.addToLog(`🔄 SWAP activated! HP: ${oldHp} → ${this.hp}/${this.maxHp}`);
                this.addToLog("🔄 Swapped with the cosmic balance!");
                this.updateDisplay();
                this.flashStatus('swap');
            }
            
            handleRevive() {
                if (this.hp > 0) {
                    if (!this.hasRevive) {
                        this.hasRevive = true;
                        this.addToLog("🔮 REVIVE prepared! Will activate automatically if you're defeated.");
                        this.updateSpecialStatus();
                    } else {
                        this.addToLog("🔮 Revive already prepared!");
                    }
                    return;
                }
                
                // Use revive when defeated
                if (this.hasRevive) {
                    this.hp = 5;
                    this.hasRevive = false;
                    this.addToLog("🔮 REVIVE activated! Back in the fight with 5 HP!");
                    this.updateDisplay();
                    this.updateSpecialStatus();
                    this.flashStatus('revive');
                } else {
                    this.addToLog("💀 No revive prepared! Cast REVIVE while alive to prepare it.");
                }
            }
            
            handleLifesteal() {
                if (this.hp === 0) {
                    this.addToLog("💀 Cannot cast spells when defeated!");
                    return;
                }
                
                if (this.lifestealActive) {
                    this.lifestealActive = false;
                    this.addToLog("🧛 LIFESTEAL deactivated.");
                } else {
                    this.lifestealActive = true;
                    this.addToLog("🧛 LIFESTEAL activated! Gain 1 HP when taking damage (if you survive)!");
                }
                
                this.updateSpecialStatus();
                this.flashStatus('lifesteal');
            }
            flashStatus(type) {
                const colors = {
                    damage: 'bg-red-500',
                    heal: 'bg-green-500', 
                    shield: 'bg-blue-500',
                    block: 'bg-yellow-500',
                    death: 'bg-red-800'
                };
                
                const originalClass = document.body.className;
                const flashClass = colors[type] || 'bg-gray-500';
                
                // Add flash effect
                document.body.style.boxShadow = `inset 0 0 20px rgba(255,255,255,0.3)`;
                
                setTimeout(() => {
                    document.body.style.boxShadow = '';
                }, 200);
            }

            // Add cleanup method
            async cleanup() {
                if (this.nfcReader && this.isListening) {
                    try {
                        await this.nfcReader.stop();
                        this.addToLog('🔄 NFC scanning stopped');
                    } catch (error) {
                        console.warn('Error stopping NFC reader:', error);
                    }
                }
                this.isListening = false;
                this.nfcReader = null;
            }
        }

        // Add page cleanup on unload
        window.addEventListener('beforeunload', () => {
            if (window.nfcBattleGame) {
                window.nfcBattleGame.cleanup();
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            window.nfcBattleGame = new NFCBattleGame();
        });
    </script>
</body>
</html>
